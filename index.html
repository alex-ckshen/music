<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            background-color: #000;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            color: white;
        }
        #root {
            width: 100vw;
            height: 100vh;
        }
        /* Custom scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); }
        ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.2); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.4); }
    </style>
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "lucide-react": "https://esm.sh/lucide-react@0.292.0"
        }
    }
    </script>
</head>
<body>
    <div id="root">
        <div style="position:fixed;top:0;left:0;width:100%;height:100%;display:flex;justify-content:center;align-items:center;background:#000;color:#666;">
            <div style="text-align:center;">
                <div style="width:40px;height:40px;border:4px solid #333;border-top-color:#3b82f6;border-radius:50%;animation:spin 1s linear infinite;margin:0 auto 20px;"></div>
                <div>Loading Visualizer...</div>
            </div>
        </div>
    </div>
    <style>@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }</style>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useCallback } from 'react';
        import { createRoot } from 'react-dom/client';
        import { Mic, Monitor, Settings, Maximize, Minimize, Volume2, MicOff, Palette, Activity, X, AlertCircle } from 'lucide-react';

        // --- CONSTANTS ---
        const FFT_SIZE = 2048;
        const DEFAULT_SMOOTHING = 0.85;

        const VisualizerMode = {
            BARS: 'Bars',
            WAVE: 'Wave',
            CIRCULAR: 'Circular',
            ORB: 'Orb'
        };

        const AudioSourceType = {
            MICROPHONE: 'Microphone',
            SYSTEM: 'System Audio',
            NONE: 'None'
        };

        const THEMES = {
            blue: { primary: '#3b82f6', secondary: '#60a5fa', accent: '#93c5fd', bg: '#0f172a' },
            red: { primary: '#ef4444', secondary: '#f87171', accent: '#fca5a5', bg: '#450a0a' },
            green: { primary: '#22c55e', secondary: '#4ade80', accent: '#86efac', bg: '#052e16' },
            purple: { primary: '#a855f7', secondary: '#c084fc', accent: '#d8b4fe', bg: '#2e1065' },
            rainbow: { primary: '#ffffff', secondary: '#ffffff', accent: '#ffffff', bg: '#000000' }
        };

        // --- AUDIO SERVICE ---
        class AudioService {
            constructor() {
                this.audioContext = null;
                this.analyser = null;
                this.source = null;
                this.stream = null;
            }

            getContext() {
                if (!this.audioContext) {
                    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                    if (AudioContextClass) {
                        this.audioContext = new AudioContextClass();
                    } else {
                        throw new Error("Web Audio API is not supported in this browser.");
                    }
                }
                return this.audioContext;
            }

            async startMicrophone() {
                this.stop();
                const ctx = this.getContext();
                if (ctx.state === 'suspended') await ctx.resume();

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    this.stream = stream;
                    this.setupAudioGraph(stream);
                } catch (error) {
                    throw error;
                }
            }

            async startSystemAudio() {
                this.stop();
                const ctx = this.getContext();
                if (ctx.state === 'suspended') await ctx.resume();

                try {
                    const stream = await navigator.mediaDevices.getDisplayMedia({ 
                        video: true,
                        audio: { autoGainControl: false, echoCancellation: false, noiseSuppression: false } 
                    });

                    // Check if user shared audio
                    if (stream.getAudioTracks().length === 0) {
                        stream.getTracks().forEach(track => track.stop());
                        throw new Error("No audio track detected. Please ensure 'Share audio' is checked in the dialog.");
                    }

                    // Stop video track immediately
                    stream.getVideoTracks().forEach(track => track.stop());
                    
                    this.stream = stream;
                    this.setupAudioGraph(stream);
                } catch (error) {
                    throw error;
                }
            }

            setupAudioGraph(stream) {
                const ctx = this.getContext();
                // Clean up previous nodes
                if (this.source) {
                    try { this.source.disconnect(); } catch(e) {}
                }
                if (this.analyser) {
                    try { this.analyser.disconnect(); } catch(e) {}
                }

                this.analyser = ctx.createAnalyser();
                this.analyser.fftSize = FFT_SIZE;
                this.analyser.smoothingTimeConstant = DEFAULT_SMOOTHING;

                this.source = ctx.createMediaStreamSource(stream);
                this.source.connect(this.analyser);
            }

            stop() {
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }
                if (this.source) {
                    try { this.source.disconnect(); } catch(e) {}
                    this.source = null;
                }
            }

            getAnalyser() {
                return this.analyser;
            }

            setSmoothing(value) {
                if (this.analyser) {
                    this.analyser.smoothingTimeConstant = value;
                }
            }
        }

        const audioService = new AudioService();

        // --- COMPONENTS ---

        const VisualizerCanvas = ({ mode, theme, customColor, isPlaying }) => {
            const canvasRef = useRef(null);
            const animationRef = useRef(null);

            const getThemeColors = () => {
                if (theme === 'custom') {
                    return { primary: customColor, secondary: customColor, accent: '#ffffff', bg: '#000000' };
                }
                return THEMES[theme] || THEMES.blue;
            };

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                if (!ctx) return;

                const analyser = audioService.getAnalyser();
                
                const handleResize = () => {
                    const dpr = window.devicePixelRatio || 1;
                    canvas.width = window.innerWidth * dpr;
                    canvas.height = window.innerHeight * dpr;
                    ctx.scale(dpr, dpr);
                    canvas.logicalWidth = window.innerWidth;
                    canvas.logicalHeight = window.innerHeight;
                };

                window.addEventListener('resize', handleResize);
                handleResize();

                const bufferLength = analyser ? analyser.frequencyBinCount : 1024;
                const dataArray = new Uint8Array(bufferLength);

                const render = () => {
                    animationRef.current = requestAnimationFrame(render);
                    const colors = getThemeColors();
                    const width = canvas.logicalWidth || window.innerWidth;
                    const height = canvas.logicalHeight || window.innerHeight;

                    // Clear with fade
                    ctx.fillStyle = mode === VisualizerMode.ORB ? 'rgba(0, 0, 0, 0.1)' : 'rgba(0, 0, 0, 0.2)';
                    ctx.fillRect(0, 0, width, height);

                    if (!isPlaying || !analyser) return;

                    analyser.getByteFrequencyData(dataArray);

                    if (mode === VisualizerMode.BARS) {
                        drawBars(ctx, dataArray, bufferLength, width, height, colors, theme === 'rainbow');
                    } else if (mode === VisualizerMode.WAVE) {
                        drawWave(ctx, dataArray, bufferLength, width, height, colors, theme === 'rainbow');
                    } else if (mode === VisualizerMode.CIRCULAR) {
                        drawCircular(ctx, dataArray, bufferLength, width, height, colors, theme === 'rainbow');
                    } else if (mode === VisualizerMode.ORB) {
                        drawOrb(ctx, dataArray, bufferLength, width, height, colors);
                    }
                };

                render();

                return () => {
                    if (animationRef.current) cancelAnimationFrame(animationRef.current);
                    window.removeEventListener('resize', handleResize);
                };
            }, [mode, theme, customColor, isPlaying]);

            const drawBars = (ctx, data, bufferLength, width, height, colors, isRainbow) => {
                const barWidth = (width / bufferLength) * 2.5;
                let x = 0;
                const effectiveLength = Math.floor(bufferLength * 0.7);

                for (let i = 0; i < effectiveLength; i++) {
                    const barHeight = (data[i] / 255) * height;
                    if (isRainbow) {
                        const hue = (i / effectiveLength) * 360;
                        ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                    } else {
                        ctx.fillStyle = barHeight > height * 0.6 ? colors.accent : colors.primary;
                    }
                    ctx.fillRect(x, height - barHeight, barWidth, barHeight);
                    // Reflection
                    ctx.globalAlpha = 0.2;
                    ctx.fillRect(x, height, barWidth, barHeight * 0.3);
                    ctx.globalAlpha = 1.0;
                    x += barWidth + 1;
                    if (x > width) break;
                }
            };

            const drawWave = (ctx, data, bufferLength, width, height, colors, isRainbow) => {
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.beginPath();
                const sliceWidth = width / bufferLength;
                let x = 0;
                ctx.moveTo(0, height / 2);

                for (let i = 0; i < bufferLength; i++) {
                    const v = data[i] / 128.0; 
                    const y = (v * height) / 2;
                    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                    x += sliceWidth;
                }
                ctx.lineTo(width, height / 2);
                if (isRainbow) {
                    const gradient = ctx.createLinearGradient(0, 0, width, 0);
                    gradient.addColorStop(0, 'red'); gradient.addColorStop(0.5, 'green'); gradient.addColorStop(1, 'blue');
                    ctx.strokeStyle = gradient;
                } else {
                    ctx.strokeStyle = colors.primary;
                    ctx.shadowBlur = 15; ctx.shadowColor = colors.secondary;
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
            };

            const drawCircular = (ctx, data, bufferLength, width, height, colors, isRainbow) => {
                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.min(width, height) / 4;
                let bass = 0;
                for(let i = 0; i < 20; i++) bass += data[i];
                bass = bass / 20;
                const pulse = (bass / 255) * 20;

                ctx.beginPath();
                ctx.arc(centerX, centerY, radius - 10 + pulse, 0, 2 * Math.PI);
                ctx.fillStyle = isRainbow ? `hsla(${bass}, 70%, 50%, 0.2)` : colors.bg;
                ctx.fill();
                ctx.strokeStyle = isRainbow ? `white` : colors.accent;
                ctx.lineWidth = 2;
                ctx.stroke();

                const bars = 180;
                const step = (Math.PI * 2) / bars;

                for (let i = 0; i < bars; i++) {
                    const dataIndex = Math.floor((i / bars) * (bufferLength / 2)); 
                    const value = data[dataIndex];
                    const barHeight = (value / 255) * (Math.min(width, height) / 3);
                    const angle = i * step;
                    const x1 = centerX + Math.cos(angle) * radius;
                    const y1 = centerY + Math.sin(angle) * radius;
                    const x2 = centerX + Math.cos(angle) * (radius + barHeight);
                    const y2 = centerY + Math.sin(angle) * (radius + barHeight);

                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    if (isRainbow) {
                        const hue = (i / bars) * 360;
                        ctx.strokeStyle = `hsl(${hue}, 80%, 60%)`;
                    } else {
                        ctx.strokeStyle = colors.primary;
                        ctx.shadowBlur = 10; ctx.shadowColor = colors.primary;
                    }
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            };

            const drawOrb = (ctx, data, bufferLength, width, height, colors) => {
                const centerX = width / 2;
                const centerY = height / 2;
                let lows = 0, mids = 0, highs = 0;
                const limit = Math.floor(bufferLength * 0.6);
                for(let i = 0; i < limit; i++) {
                    if(i < limit * 0.1) lows += data[i];
                    else if(i < limit * 0.5) mids += data[i];
                    else highs += data[i];
                }
                lows /= (limit * 0.1); mids /= (limit * 0.4); highs /= (limit * 0.5);
                const baseRadius = Math.min(width, height) / 6;

                ctx.beginPath();
                const r1 = baseRadius + (lows / 255) * 100;
                ctx.arc(centerX, centerY, r1, 0, Math.PI * 2);
                ctx.fillStyle = colors.primary;
                ctx.globalAlpha = 0.8; ctx.shadowBlur = 50; ctx.shadowColor = colors.primary;
                ctx.fill();

                ctx.beginPath();
                const r2 = baseRadius * 1.5 + (mids / 255) * 80;
                ctx.arc(centerX, centerY, r2, 0, Math.PI * 2);
                ctx.strokeStyle = colors.secondary;
                ctx.lineWidth = 4; ctx.globalAlpha = 0.6; ctx.shadowBlur = 30; ctx.shadowColor = colors.secondary;
                ctx.stroke();

                ctx.beginPath();
                const r3 = baseRadius * 2 + (highs / 255) * 120;
                ctx.arc(centerX, centerY, r3, 0, Math.PI * 2);
                ctx.strokeStyle = colors.accent;
                ctx.lineWidth = 1; ctx.globalAlpha = 0.4;
                ctx.stroke();
                ctx.globalAlpha = 1.0; ctx.shadowBlur = 0;
            };

            return (
                <canvas ref={canvasRef} className="fixed inset-0 w-full h-full pointer-events-none" style={{ touchAction: 'none' }} />
            );
        };

        const Controls = ({ appState, audioSource, updateState, onToggleMic, onToggleSystem, isFullscreen, toggleFullscreen }) => {
            const [showSettings, setShowSettings] = useState(false);
            const [visible, setVisible] = useState(true);
            const [lastMouseMove, setLastMouseMove] = useState(Date.now());

            useEffect(() => {
                const handleMouseMove = () => { setLastMouseMove(Date.now()); setVisible(true); };
                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('touchstart', handleMouseMove);
                const interval = setInterval(() => {
                    if (Date.now() - lastMouseMove > 3000 && !showSettings) setVisible(false);
                }, 1000);
                return () => {
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('touchstart', handleMouseMove);
                    clearInterval(interval);
                };
            }, [lastMouseMove, showSettings]);

            const controlClasses = `fixed z-50 transition-opacity duration-500 ease-in-out ${visible ? 'opacity-100' : 'opacity-0 pointer-events-none'}`;

            return (
                <React.Fragment>
                    <div className={`${controlClasses} top-6 right-6 flex gap-3`}>
                        <button onClick={onToggleMic} className={`p-3 rounded-full backdrop-blur-md transition-all duration-300 border border-white/10 ${audioSource === AudioSourceType.MICROPHONE ? 'bg-green-500/80 text-white shadow-[0_0_15px_rgba(34,197,94,0.5)]' : 'bg-black/40 text-white/70 hover:bg-white/10 hover:text-white'}`} title="Toggle Microphone">
                            {audioSource === AudioSourceType.MICROPHONE ? <Mic size={20} /> : <MicOff size={20} />}
                        </button>
                        <button onClick={onToggleSystem} className={`p-3 rounded-full backdrop-blur-md transition-all duration-300 border border-white/10 ${audioSource === AudioSourceType.SYSTEM ? 'bg-blue-500/80 text-white shadow-[0_0_15px_rgba(59,130,246,0.5)]' : 'bg-black/40 text-white/70 hover:bg-white/10 hover:text-white'}`} title="Toggle System Audio">
                            <Monitor size={20} />
                        </button>
                        <button onClick={() => setShowSettings(true)} className="p-3 rounded-full bg-black/40 text-white/70 backdrop-blur-md border border-white/10 hover:bg-white/10 hover:text-white transition-all duration-300" title="Settings">
                            <Settings size={20} />
                        </button>
                        <button onClick={toggleFullscreen} className="p-3 rounded-full bg-black/40 text-white/70 backdrop-blur-md border border-white/10 hover:bg-white/10 hover:text-white transition-all duration-300 hidden md:flex" title="Toggle Fullscreen">
                            {isFullscreen ? <Minimize size={20} /> : <Maximize size={20} />}
                        </button>
                    </div>

                    {showSettings && (
                        <div className="fixed inset-0 z-[60] flex items-center justify-center bg-black/60 backdrop-blur-sm p-4 animate-in fade-in duration-200">
                            <div className="bg-neutral-900/90 border border-white/10 rounded-2xl w-full max-w-md overflow-hidden shadow-2xl flex flex-col max-h-[90vh]">
                                <div className="p-5 border-b border-white/10 flex justify-between items-center bg-white/5">
                                    <h2 className="text-xl font-bold text-white tracking-wide">Configuration</h2>
                                    <button onClick={() => setShowSettings(false)} className="text-white/50 hover:text-white transition-colors"><X size={24} /></button>
                                </div>
                                <div className="p-6 overflow-y-auto space-y-8">
                                    <div className="space-y-3">
                                        <div className="flex items-center gap-2 text-sm font-medium text-white/80 uppercase tracking-wider"><Activity size={16} /> Visualization Style</div>
                                        <div className="grid grid-cols-2 gap-2">
                                            {Object.values(VisualizerMode).map((m) => (
                                                <button key={m} onClick={() => updateState({ mode: m })} className={`px-4 py-3 rounded-lg text-sm font-medium transition-all ${appState.mode === m ? 'bg-white text-black shadow-lg' : 'bg-white/5 text-white/70 hover:bg-white/10'}`}>{m}</button>
                                            ))}
                                        </div>
                                    </div>
                                    <div className="space-y-3">
                                        <div className="flex items-center gap-2 text-sm font-medium text-white/80 uppercase tracking-wider"><Palette size={16} /> Color Theme</div>
                                        <div className="flex flex-wrap gap-3">
                                            {Object.keys(THEMES).map((t) => (
                                                <button key={t} onClick={() => updateState({ theme: t })} className={`h-10 px-4 rounded-full border flex items-center gap-2 transition-all capitalize ${appState.theme === t ? 'border-white bg-white/10 text-white' : 'border-transparent bg-white/5 text-white/60 hover:bg-white/10'}`}>
                                                    <div className="w-3 h-3 rounded-full" style={{ backgroundColor: t === 'rainbow' ? 'white' : THEMES[t].primary, ...(t === 'rainbow' ? { background: 'linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet)' } : {}) }} />
                                                    {t}
                                                </button>
                                            ))}
                                            <button onClick={() => updateState({ theme: 'custom' })} className={`h-10 px-4 rounded-full border flex items-center gap-2 transition-all ${appState.theme === 'custom' ? 'border-white bg-white/10 text-white' : 'border-transparent bg-white/5 text-white/60 hover:bg-white/10'}`}>Custom</button>
                                        </div>
                                        {appState.theme === 'custom' && (
                                            <div className="mt-3 p-4 bg-white/5 rounded-xl border border-white/5 animate-in slide-in-from-top-2">
                                                <label className="text-xs text-white/50 mb-2 block">Pick a color</label>
                                                <div className="flex items-center gap-3">
                                                    <input type="color" value={appState.customColor} onChange={(e) => updateState({ customColor: e.target.value })} className="w-10 h-10 rounded cursor-pointer bg-transparent border-none" />
                                                    <span className="text-white/80 font-mono text-sm">{appState.customColor}</span>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                    <div className="space-y-4 pt-4 border-t border-white/10">
                                        <div className="flex items-center gap-2 text-sm font-medium text-white/80 uppercase tracking-wider"><Volume2 size={16} /> Sensitivity</div>
                                        <input type="range" min="0.5" max="0.99" step="0.01" value={appState.smoothing} onChange={(e) => updateState({ smoothing: parseFloat(e.target.value) })} className="w-full h-2 bg-white/10 rounded-lg appearance-none cursor-pointer accent-white" />
                                        <div className="flex justify-between text-xs text-white/40"><span>Fast Response</span><span>Smooth</span></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}
                    {audioSource === AudioSourceType.NONE && (
                        <div className="fixed inset-0 flex items-center justify-center pointer-events-none z-10">
                            <div className="bg-black/60 backdrop-blur-md text-white px-8 py-4 rounded-full border border-white/10 animate-pulse text-center">
                                <p className="font-semibold text-lg">Waiting for Input</p>
                                <p className="text-sm text-white/60">Click Mic or Screen icons to begin</p>
                            </div>
                        </div>
                    )}
                </React.Fragment>
            );
        };

        class ErrorBoundary extends React.Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false, error: null };
            }
            static getDerivedStateFromError(error) {
                return { hasError: true, error };
            }
            render() {
                if (this.state.hasError) {
                    return (
                        <div className="flex flex-col items-center justify-center h-screen bg-neutral-900 text-white p-8 text-center">
                            <AlertCircle size={48} className="text-red-500 mb-4" />
                            <h1 className="text-2xl font-bold mb-2">Something went wrong</h1>
                            <pre className="bg-black p-4 rounded text-left text-xs text-red-300 overflow-auto max-w-2xl">
                                {this.state.error.toString()}
                            </pre>
                            <button onClick={() => window.location.reload()} className="mt-6 px-6 py-2 bg-white text-black rounded-full hover:bg-gray-200">
                                Reload Application
                            </button>
                        </div>
                    );
                }
                return this.props.children;
            }
        }

        const App = () => {
            const [appState, setAppState] = useState({
                mode: VisualizerMode.CIRCULAR,
                theme: 'blue',
                customColor: '#ff00ff',
                sensitivity: 1,
                smoothing: DEFAULT_SMOOTHING,
                showControls: true
            });
            const [audioSource, setAudioSource] = useState(AudioSourceType.NONE);
            const [isFullscreen, setIsFullscreen] = useState(false);
            const [errorMsg, setErrorMsg] = useState(null);

            useEffect(() => {
                try { audioService.setSmoothing(appState.smoothing); } catch (e) { console.warn("Failed to set smoothing", e); }
            }, [appState.smoothing]);

            const updateState = (partial) => setAppState(prev => ({ ...prev, ...partial }));

            const handleToggleMic = async () => {
                setErrorMsg(null);
                try {
                    if (audioSource === AudioSourceType.MICROPHONE) {
                        audioService.stop();
                        setAudioSource(AudioSourceType.NONE);
                    } else {
                        await audioService.startMicrophone();
                        setAudioSource(AudioSourceType.MICROPHONE);
                    }
                } catch (err) {
                    if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                        console.log("Microphone selection cancelled.");
                    } else {
                        console.error("Failed to toggle mic", err);
                        setErrorMsg("Could not access microphone. Please check browser permissions.");
                    }
                }
            };

            const handleToggleSystem = async () => {
                setErrorMsg(null);
                try {
                    if (audioSource === AudioSourceType.SYSTEM) {
                        audioService.stop();
                        setAudioSource(AudioSourceType.NONE);
                    } else {
                        await audioService.startSystemAudio();
                        setAudioSource(AudioSourceType.SYSTEM);
                    }
                } catch (err) {
                    if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                        console.log("System audio selection cancelled.");
                    } else {
                        console.error("Failed to toggle system audio", err);
                        setErrorMsg(err.message || "Could not access system audio.");
                    }
                }
            };

            const handleToggleFullscreen = useCallback(() => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch((e) => console.error(e));
                    setIsFullscreen(true);
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                        setIsFullscreen(false);
                    }
                }
            }, []);

            useEffect(() => {
                const onFullscreenChange = () => setIsFullscreen(!!document.fullscreenElement);
                document.addEventListener('fullscreenchange', onFullscreenChange);
                return () => document.removeEventListener('fullscreenchange', onFullscreenChange);
            }, []);

            useEffect(() => {
                let wakeLock = null;
                const requestWakeLock = async () => {
                    if ('wakeLock' in navigator) {
                        try { wakeLock = await navigator.wakeLock.request('screen'); } catch (err) { console.warn('Wake Lock error:', err); }
                    }
                };
                if (audioSource !== AudioSourceType.NONE) requestWakeLock();
                return () => { if (wakeLock) wakeLock.release().catch(console.error); };
            }, [audioSource]);

            return (
                <div className="relative w-full h-screen bg-black overflow-hidden select-none">
                    <VisualizerCanvas mode={appState.mode} theme={appState.theme} customColor={appState.customColor} isPlaying={audioSource !== AudioSourceType.NONE} />
                    <Controls appState={appState} audioSource={audioSource} updateState={updateState} onToggleMic={handleToggleMic} onToggleSystem={handleToggleSystem} isFullscreen={isFullscreen} toggleFullscreen={handleToggleFullscreen} />
                    {errorMsg && (
                        <div className="fixed top-20 left-1/2 transform -translate-x-1/2 bg-red-500/90 text-white px-6 py-3 rounded-lg shadow-lg z-50 animate-in fade-in slide-in-from-top-4 flex gap-4 items-center">
                            <span>{errorMsg}</span>
                            <button onClick={() => setErrorMsg(null)} className="font-bold hover:text-black">âœ•</button>
                        </div>
                    )}
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(
            <ErrorBoundary>
                <App />
            </ErrorBoundary>
        );
    </script>
</body>
</html>
