<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Visualizer Screensaver</title>
    <style>
        body {
            margin: 0;
            background: black;
            overflow: hidden;
            color: white;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            filter: blur(2px); /* Subtle overall blur for fluidity */
        }
        #fullscreen-btn, #settings-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            cursor: pointer;
            z-index: 10;
        }
        #settings-btn {
            right: 120px;
        }
        #fullscreen-btn:hover, #settings-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        #settings-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            z-index: 20;
            display: none;
            max-width: 300px;
        }
        #settings-panel label {
            display: block;
            margin: 10px 0;
        }
        #settings-panel ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #settings-panel li {
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            margin: 5px 0;
            cursor: pointer;
            text-align: center;
        }
        #settings-panel li:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        #settings-panel li.selected {
            background: rgba(255, 255, 255, 0.3);
        }
        #custom-color-picker {
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <button id="fullscreen-btn">Fullscreen</button>
    <button id="settings-btn">Settings</button>
    <div id="settings-panel">
        <label>Color Theme:</label>
        <ul id="theme-list">
            <li data-theme="blue" class="selected">Blue (Default)</li>
            <li data-theme="red">Fiery Red</li>
            <li data-theme="green">Vibrant Green</li>
            <li data-theme="purple">Purple Haze</li>
            <li data-theme="rainbow">Rainbow</li>
            <li data-theme="custom">Custom</li>
        </ul>
        <div id="custom-color-picker">
            <label for="custom-color">Choose Main Color:</label>
            <input type="color" id="custom-color" value="#0000FF">
        </div>

        <label>Visualization Style:</label>
        <ul id="viz-list">
            <li data-viz="bars">Bars</li>
            <li data-viz="waves">Waves</li>
            <li data-viz="circular" class="selected">Circular (Default)</li>
        </ul>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const settingsBtn = document.getElementById('settings-btn');
        const settingsPanel = document.getElementById('settings-panel');
        const themeList = document.getElementById('theme-list');
        const vizList = document.getElementById('viz-list');
        const customColorPicker = document.getElementById('custom-color-picker');
        const customColor = document.getElementById('custom-color');

        let currentTheme = 'blue';
        let currentViz = 'circular'; // Default to circular
        let mainHue = 210; // Blue

        const themeHues = {
            blue: 210,
            red: 0,
            green: 120,
            purple: 270,
            rainbow: null
        };

        function hexToHsl(hex) {
            let r = parseInt(hex.slice(1, 3), 16) / 255;
            let g = parseInt(hex.slice(3, 5), 16) / 255;
            let b = parseInt(hex.slice(5, 7), 16) / 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) {
                h = s = 0;
            } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [h * 360, s * 100, l * 100];
        }

        function updateTheme() {
            if (currentTheme === 'custom') {
                const [h] = hexToHsl(customColor.value);
                mainHue = h;
            } else {
                mainHue = themeHues[currentTheme];
            }
        }

        // Clickable list for themes
        themeList.querySelectorAll('li').forEach(li => {
            li.addEventListener('click', () => {
                themeList.querySelectorAll('li').forEach(l => l.classList.remove('selected'));
                li.classList.add('selected');
                currentTheme = li.dataset.theme;
                customColorPicker.style.display = currentTheme === 'custom' ? 'block' : 'none';
                updateTheme();
            });
        });

        // Clickable list for viz
        vizList.querySelectorAll('li').forEach(li => {
            li.addEventListener('click', () => {
                vizList.querySelectorAll('li').forEach(l => l.classList.remove('selected'));
                li.classList.add('selected');
                currentViz = li.dataset.viz;
            });
        });

        customColor.addEventListener('input', updateTheme);

        // Close settings on click outside
        document.addEventListener('click', (event) => {
            if (!settingsPanel.contains(event.target) && event.target !== settingsBtn) {
                settingsPanel.style.display = 'none';
            }
        });

        settingsBtn.addEventListener('click', () => {
            settingsPanel.style.display = 'block';
        });

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => console.error(err));
            } else {
                document.exitFullscreen();
            }
        });

        // Explicitly trigger getDisplayMedia to ensure share screen popup
        function startScreenShare() {
            navigator.mediaDevices.getDisplayMedia({ video: true, audio: true })
                .then(stream => {
                    // Stop video tracks immediately to avoid displaying screen
                    stream.getVideoTracks().forEach(track => track.stop());

                    // Use only audio tracks
                    const audioStream = new MediaStream(stream.getAudioTracks());

                    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    const source = audioCtx.createMediaStreamSource(audioStream);
                    const analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 2048;
                    source.connect(analyser);

                    const bufferLength = analyser.frequencyBinCount;
                    const dataArray = new Uint8Array(bufferLength);

                    // Create shuffled indices for randomization (no repeat)
                    let shuffled = Array.from({length: bufferLength}, (_, i) => i);
                    // Fisher-Yates shuffle
                    for (let i = shuffled.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                    }
                    const effectiveLength = bufferLength;

                    let rotationOffset = 0; // For dynamic rotation

                    function getColor(i, effectiveLength) {
                        if (currentTheme === 'rainbow') {
                            return `hsl(${i * 360 / effectiveLength}, 100%, 50%)`;
                        } else {
                            const hueVariation = (i / effectiveLength - 0.5) * 60;
                            const variedHue = (mainHue + hueVariation + 360) % 360;
                            return `hsl(${variedHue}, 80%, 60%)`;
                        }
                    }

                    function draw() {
                        requestAnimationFrame(draw);
                        analyser.getByteFrequencyData(dataArray);

                        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);

                        // Find max for normalization
                        let maxData = 0;
                        for (let i = 0; i < bufferLength; i++) {
                            if (dataArray[i] > maxData) maxData = dataArray[i];
                        }
                        const scale = maxData > 0 ? 255 / maxData : 1;

                        // Bass for pulsing circle
                        let bass = 0;
                        for (let i = 0; i < 50; i++) {
                            bass += dataArray[i];
                        }
                        bass /= 50 * 255;
                        const bassRadius = 50 + bass * 150;

                        ctx.beginPath();
                        ctx.arc(canvas.width / 2, canvas.height / 2, bassRadius, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 255, 255, ${bass * 0.5})`;
                        ctx.shadowBlur = 30;
                        ctx.shadowColor = getColor(effectiveLength / 2, effectiveLength);
                        ctx.fill();
                        ctx.shadowBlur = 0;

                        if (currentViz === 'bars') {
                            const barWidth = (canvas.width / bufferLength) * 2.5;
                            let x = 0;
                            for (let i = 0; i < bufferLength; i++) {
                                const normalized = dataArray[i] * scale / 255;
                                const height = normalized * (canvas.height / 3);
                                const color = getColor(i, bufferLength);
                                ctx.fillStyle = color;
                                ctx.shadowBlur = 10;
                                ctx.shadowColor = color;
                                ctx.fillRect(x, canvas.height - height, barWidth, height);
                                ctx.fillRect(x, 0, barWidth, height);
                                ctx.shadowBlur = 0;
                                x += barWidth;
                            }
                        } else if (currentViz === 'waves') {
                            const centerX = canvas.width / 2;
                            const halfLength = bufferLength / 2;
                            const sliceWidth = canvas.width / bufferLength;

                            // Bottom wave - right from center
                            ctx.beginPath();
                            ctx.moveTo(centerX, canvas.height / 2);
                            let x = centerX;
                            for (let i = 0; i < halfLength; i++) {
                                const normalized = dataArray[i] * scale / 255;
                                const v = normalized;
                                const y = canvas.height / 2 + v * (canvas.height / 4);
                                ctx.lineTo(x, y);
                                x += sliceWidth;
                            }
                            ctx.strokeStyle = getColor(halfLength, bufferLength);
                            ctx.lineWidth = 2;
                            ctx.stroke();

                            // Bottom wave - left from center (mirrored)
                            ctx.beginPath();
                            ctx.moveTo(centerX, canvas.height / 2);
                            x = centerX;
                            for (let i = 0; i < halfLength; i++) {
                                const normalized = dataArray[i] * scale / 255;
                                const v = normalized;
                                const y = canvas.height / 2 + v * (canvas.height / 4);
                                ctx.lineTo(x, y);
                                x -= sliceWidth;
                            }
                            ctx.stroke();

                            // Mirror to top - right
                            ctx.beginPath();
                            ctx.moveTo(centerX, canvas.height / 2);
                            x = centerX;
                            for (let i = 0; i < halfLength; i++) {
                                const normalized = dataArray[i] * scale / 255;
                                const v = normalized;
                                const y = canvas.height / 2 - v * (canvas.height / 4);
                                ctx.lineTo(x, y);
                                x += sliceWidth;
                            }
                            ctx.stroke();

                            // Mirror to top - left
                            ctx.beginPath();
                            ctx.moveTo(centerX, canvas.height / 2);
                            x = centerX;
                            for (let i = 0; i < halfLength; i++) {
                                const normalized = dataArray[i] * scale / 255;
                                const v = normalized;
                                const y = canvas.height / 2 - v * (canvas.height / 4);
                                ctx.lineTo(x, y);
                                x -= sliceWidth;
                            }
                            ctx.stroke();
                        } else if (currentViz === 'circular') {
                            const centerX = canvas.width / 2;
                            const centerY = canvas.height / 2;
                            const baseRadius = Math.min(centerX, centerY) / 3;
                            const maxOffset = baseRadius * 1.5;

                            // Fixed max rotation speed (randomness 100)
                            rotationOffset = (rotationOffset + 0.5) % effectiveLength;

                            ctx.beginPath();
                            for (let i = 0; i < effectiveLength; i++) {
                                const shiftedIndex = (i + Math.floor(rotationOffset)) % effectiveLength;
                                const binIndex = shuffled[shiftedIndex];
                                let normalized = dataArray[binIndex] * scale / 255;
                                // Randomly set to zero for gaps (30% chance)
                                if (Math.random() < 0.3) {
                                    normalized = 0;
                                }
                                const radius = baseRadius + normalized * maxOffset;
                                const angle = (i / effectiveLength) * Math.PI * 2;
                                const px = centerX + radius * Math.cos(angle);
                                const py = centerY + radius * Math.sin(angle);
                                if (i === 0) {
                                    ctx.moveTo(px, py);
                                } else {
                                    ctx.lineTo(px, py);
                                }
                            }
                            ctx.closePath();
                            const centralColor = getColor(effectiveLength / 2, effectiveLength);
                            ctx.strokeStyle = centralColor;
                            ctx.lineWidth = 2;
                            ctx.shadowBlur = 10;
                            ctx.shadowColor = centralColor;
                            ctx.stroke();
                            ctx.shadowBlur = 0;
                        }
                    }

                    draw();
                })
                .catch(err => {
                    console.error('Error accessing screen/audio:', err);
                    alert('Please allow screen sharing with audio to visualize any audio playing on your device. Select "Share audio" in the prompt. If the popup doesn\'t appear, ensure your browser permissions allow it.');
                });
        }

        // Trigger screen sharing when the page loads
        window.addEventListener('load', startScreenShare);

        // Initialize
        updateTheme();
    </script>
</body>
</html>
